// This file is @generated by prost-build.
/// Params defines the parameters for the module.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Params {
    #[prost(uint64, repeated, tag = "1")]
    pub fee_tiers: ::prost::alloc::vec::Vec<u64>,
    #[prost(bool, tag = "3")]
    pub paused: bool,
    #[prost(uint64, tag = "4")]
    pub max_jits_per_block: u64,
    #[prost(uint64, tag = "5")]
    pub good_til_purge_allowance: u64,
    /// Whitelisted_lps have special LP privileges;
    /// currently, the only such privilege is depositing outside of the allowed fee_tiers.
    #[prost(string, repeated, tag = "6")]
    pub whitelisted_lps: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for Params {
    const NAME: &'static str = "Params";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.Params".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.Params".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DepositOptions {
    #[prost(bool, tag = "1")]
    pub disable_autoswap: bool,
    #[prost(bool, tag = "2")]
    pub fail_tx_on_bel: bool,
    #[prost(bool, tag = "3")]
    pub swap_on_deposit: bool,
    #[prost(uint64, tag = "4")]
    pub swap_on_deposit_slop_tolerance_bps: u64,
}
impl ::prost::Name for DepositOptions {
    const NAME: &'static str = "DepositOptions";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.DepositOptions".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.DepositOptions".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgDeposit {
    #[prost(string, tag = "1")]
    pub creator: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub receiver: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub token_a: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub token_b: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub amounts_a: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "6")]
    pub amounts_b: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, repeated, tag = "7")]
    pub tick_indexes_a_to_b: ::prost::alloc::vec::Vec<i64>,
    #[prost(uint64, repeated, tag = "8")]
    pub fees: ::prost::alloc::vec::Vec<u64>,
    #[prost(message, repeated, tag = "9")]
    pub options: ::prost::alloc::vec::Vec<DepositOptions>,
}
impl ::prost::Name for MsgDeposit {
    const NAME: &'static str = "MsgDeposit";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.MsgDeposit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.MsgDeposit".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FailedDeposit {
    #[prost(uint64, tag = "1")]
    pub deposit_idx: u64,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
}
impl ::prost::Name for FailedDeposit {
    const NAME: &'static str = "FailedDeposit";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.FailedDeposit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.FailedDeposit".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgDepositResponse {
    #[prost(string, repeated, tag = "1")]
    pub reserve0_deposited: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub reserve1_deposited: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub failed_deposits: ::prost::alloc::vec::Vec<FailedDeposit>,
    #[prost(message, repeated, tag = "4")]
    pub shares_issued: ::prost::alloc::vec::Vec<
        cosmos_sdk_proto::cosmos::base::v1beta1::Coin,
    >,
}
impl ::prost::Name for MsgDepositResponse {
    const NAME: &'static str = "MsgDepositResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.MsgDepositResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.MsgDepositResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgWithdrawal {
    #[prost(string, tag = "1")]
    pub creator: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub receiver: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub token_a: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub token_b: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub shares_to_remove: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, repeated, tag = "6")]
    pub tick_indexes_a_to_b: ::prost::alloc::vec::Vec<i64>,
    #[prost(uint64, repeated, tag = "7")]
    pub fees: ::prost::alloc::vec::Vec<u64>,
}
impl ::prost::Name for MsgWithdrawal {
    const NAME: &'static str = "MsgWithdrawal";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.MsgWithdrawal".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.MsgWithdrawal".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgWithdrawalResponse {
    #[prost(string, tag = "1")]
    pub reserve0_withdrawn: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reserve1_withdrawn: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub shares_burned: ::prost::alloc::vec::Vec<
        cosmos_sdk_proto::cosmos::base::v1beta1::Coin,
    >,
}
impl ::prost::Name for MsgWithdrawalResponse {
    const NAME: &'static str = "MsgWithdrawalResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.MsgWithdrawalResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.MsgWithdrawalResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgPlaceLimitOrder {
    #[prost(string, tag = "1")]
    pub creator: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub receiver: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub token_in: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub token_out: ::prost::alloc::string::String,
    /// DEPRECATED: tick_index_in_to_out will be removed in future release; limit_sell_price should be used instead.
    #[deprecated]
    #[prost(int64, tag = "5")]
    pub tick_index_in_to_out: i64,
    #[prost(string, tag = "7")]
    pub amount_in: ::prost::alloc::string::String,
    #[prost(enumeration = "LimitOrderType", tag = "8")]
    pub order_type: i32,
    /// expirationTime is only valid iff orderType == GOOD_TIL_TIME.
    #[prost(message, optional, tag = "9")]
    pub expiration_time: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    #[prost(string, tag = "10")]
    pub max_amount_out: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub limit_sell_price: ::prost::alloc::string::String,
    /// min_average_sell_price is an optional parameter that sets a required minimum average price for the entire trade.
    /// if the min_average_sell_price is not met the trade will fail.
    /// If min_average_sell_price is omitted limit_sell_price will be used instead
    #[prost(string, tag = "12")]
    pub min_average_sell_price: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgPlaceLimitOrder {
    const NAME: &'static str = "MsgPlaceLimitOrder";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.MsgPlaceLimitOrder".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.MsgPlaceLimitOrder".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgPlaceLimitOrderResponse {
    #[prost(string, tag = "1")]
    pub tranche_key: ::prost::alloc::string::String,
    /// Total amount of coin used for the limit order
    #[prost(message, optional, tag = "2")]
    pub coin_in: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// Total amount of coin received from the taker portion of the limit order
    /// This is the amount of coin immediately available in the users account after
    /// executing the limit order. It does not include any future proceeds from the
    /// maker portion which will have withdrawn in the future
    #[prost(message, optional, tag = "3")]
    pub taker_coin_out: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::v1beta1::Coin,
    >,
    /// Total amount of the token in that was immediately swapped for takerOutCoin
    #[prost(message, optional, tag = "4")]
    pub taker_coin_in: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
impl ::prost::Name for MsgPlaceLimitOrderResponse {
    const NAME: &'static str = "MsgPlaceLimitOrderResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.MsgPlaceLimitOrderResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.MsgPlaceLimitOrderResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgWithdrawFilledLimitOrder {
    #[prost(string, tag = "1")]
    pub creator: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tranche_key: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgWithdrawFilledLimitOrder {
    const NAME: &'static str = "MsgWithdrawFilledLimitOrder";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.MsgWithdrawFilledLimitOrder".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.MsgWithdrawFilledLimitOrder".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgWithdrawFilledLimitOrderResponse {
    /// Total amount of taker reserves that were withdrawn
    #[prost(message, optional, tag = "1")]
    pub taker_coin_out: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::v1beta1::Coin,
    >,
    /// Total amount of maker reserves that were withdrawn --only applies to inactive LimitOrders
    #[prost(message, optional, tag = "2")]
    pub maker_coin_out: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::v1beta1::Coin,
    >,
}
impl ::prost::Name for MsgWithdrawFilledLimitOrderResponse {
    const NAME: &'static str = "MsgWithdrawFilledLimitOrderResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.MsgWithdrawFilledLimitOrderResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.MsgWithdrawFilledLimitOrderResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgCancelLimitOrder {
    #[prost(string, tag = "1")]
    pub creator: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tranche_key: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgCancelLimitOrder {
    const NAME: &'static str = "MsgCancelLimitOrder";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.MsgCancelLimitOrder".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.MsgCancelLimitOrder".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgCancelLimitOrderResponse {
    /// Total amount of taker reserves that were withdrawn
    #[prost(message, optional, tag = "1")]
    pub taker_coin_out: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::v1beta1::Coin,
    >,
    /// Total amount of maker reserves that were canceled
    #[prost(message, optional, tag = "2")]
    pub maker_coin_out: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::v1beta1::Coin,
    >,
}
impl ::prost::Name for MsgCancelLimitOrderResponse {
    const NAME: &'static str = "MsgCancelLimitOrderResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.MsgCancelLimitOrderResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.MsgCancelLimitOrderResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MultiHopRoute {
    #[prost(string, repeated, tag = "1")]
    pub hops: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for MultiHopRoute {
    const NAME: &'static str = "MultiHopRoute";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.MultiHopRoute".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.MultiHopRoute".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMultiHopSwap {
    #[prost(string, tag = "1")]
    pub creator: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub receiver: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub routes: ::prost::alloc::vec::Vec<MultiHopRoute>,
    #[prost(string, tag = "4")]
    pub amount_in: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub exit_limit_price: ::prost::alloc::string::String,
    /// If pickBestRoute == true then all routes are run and the route with the
    /// best price is chosen otherwise, the first succesful route is used.
    #[prost(bool, tag = "6")]
    pub pick_best_route: bool,
}
impl ::prost::Name for MsgMultiHopSwap {
    const NAME: &'static str = "MsgMultiHopSwap";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.MsgMultiHopSwap".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.MsgMultiHopSwap".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMultiHopSwapResponse {
    #[prost(message, optional, tag = "1")]
    pub coin_out: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    #[prost(message, optional, tag = "2")]
    pub route: ::core::option::Option<MultiHopRoute>,
    #[prost(message, repeated, tag = "3")]
    pub dust: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
impl ::prost::Name for MsgMultiHopSwapResponse {
    const NAME: &'static str = "MsgMultiHopSwapResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.MsgMultiHopSwapResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.MsgMultiHopSwapResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgUpdateParams {
    /// Authority is the address of the governance account.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// NOTE: All parameters must be supplied.
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for MsgUpdateParams {
    const NAME: &'static str = "MsgUpdateParams";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.MsgUpdateParams".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.MsgUpdateParams".into()
    }
}
/// MsgUpdateParamsResponse defines the response structure for executing a
/// MsgUpdateParams message.
///
/// Since: 0.47
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MsgUpdateParamsResponse {}
impl ::prost::Name for MsgUpdateParamsResponse {
    const NAME: &'static str = "MsgUpdateParamsResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.MsgUpdateParamsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.MsgUpdateParamsResponse".into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LimitOrderType {
    GoodTilCancelled = 0,
    FillOrKill = 1,
    ImmediateOrCancel = 2,
    JustInTime = 3,
    GoodTilTime = 4,
}
impl LimitOrderType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::GoodTilCancelled => "GOOD_TIL_CANCELLED",
            Self::FillOrKill => "FILL_OR_KILL",
            Self::ImmediateOrCancel => "IMMEDIATE_OR_CANCEL",
            Self::JustInTime => "JUST_IN_TIME",
            Self::GoodTilTime => "GOOD_TIL_TIME",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GOOD_TIL_CANCELLED" => Some(Self::GoodTilCancelled),
            "FILL_OR_KILL" => Some(Self::FillOrKill),
            "IMMEDIATE_OR_CANCEL" => Some(Self::ImmediateOrCancel),
            "JUST_IN_TIME" => Some(Self::JustInTime),
            "GOOD_TIL_TIME" => Some(Self::GoodTilTime),
            _ => None,
        }
    }
}
/// Generated client implementations.
#[cfg(feature = "client")]
pub mod msg_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Msg defines the Msg service.
    #[derive(Debug, Clone)]
    pub struct MsgClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    #[cfg(feature = "transport")]
    impl MsgClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MsgClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MsgClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MsgClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn deposit(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgDeposit>,
        ) -> std::result::Result<
            tonic::Response<super::MsgDepositResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/neutron.dex.Msg/Deposit");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("neutron.dex.Msg", "Deposit"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn withdrawal(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgWithdrawal>,
        ) -> std::result::Result<
            tonic::Response<super::MsgWithdrawalResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Msg/Withdrawal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Msg", "Withdrawal"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn place_limit_order(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgPlaceLimitOrder>,
        ) -> std::result::Result<
            tonic::Response<super::MsgPlaceLimitOrderResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Msg/PlaceLimitOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Msg", "PlaceLimitOrder"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn withdraw_filled_limit_order(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgWithdrawFilledLimitOrder>,
        ) -> std::result::Result<
            tonic::Response<super::MsgWithdrawFilledLimitOrderResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Msg/WithdrawFilledLimitOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Msg", "WithdrawFilledLimitOrder"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn cancel_limit_order(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgCancelLimitOrder>,
        ) -> std::result::Result<
            tonic::Response<super::MsgCancelLimitOrderResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Msg/CancelLimitOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Msg", "CancelLimitOrder"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn multi_hop_swap(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgMultiHopSwap>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMultiHopSwapResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Msg/MultiHopSwap",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Msg", "MultiHopSwap"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_params(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateParams>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Msg/UpdateParams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Msg", "UpdateParams"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
#[cfg(feature = "server")]
pub mod msg_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with MsgServer.
    #[async_trait]
    pub trait Msg: std::marker::Send + std::marker::Sync + 'static {
        async fn deposit(
            &self,
            request: tonic::Request<super::MsgDeposit>,
        ) -> std::result::Result<
            tonic::Response<super::MsgDepositResponse>,
            tonic::Status,
        >;
        async fn withdrawal(
            &self,
            request: tonic::Request<super::MsgWithdrawal>,
        ) -> std::result::Result<
            tonic::Response<super::MsgWithdrawalResponse>,
            tonic::Status,
        >;
        async fn place_limit_order(
            &self,
            request: tonic::Request<super::MsgPlaceLimitOrder>,
        ) -> std::result::Result<
            tonic::Response<super::MsgPlaceLimitOrderResponse>,
            tonic::Status,
        >;
        async fn withdraw_filled_limit_order(
            &self,
            request: tonic::Request<super::MsgWithdrawFilledLimitOrder>,
        ) -> std::result::Result<
            tonic::Response<super::MsgWithdrawFilledLimitOrderResponse>,
            tonic::Status,
        >;
        async fn cancel_limit_order(
            &self,
            request: tonic::Request<super::MsgCancelLimitOrder>,
        ) -> std::result::Result<
            tonic::Response<super::MsgCancelLimitOrderResponse>,
            tonic::Status,
        >;
        async fn multi_hop_swap(
            &self,
            request: tonic::Request<super::MsgMultiHopSwap>,
        ) -> std::result::Result<
            tonic::Response<super::MsgMultiHopSwapResponse>,
            tonic::Status,
        >;
        async fn update_params(
            &self,
            request: tonic::Request<super::MsgUpdateParams>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateParamsResponse>,
            tonic::Status,
        >;
    }
    /// Msg defines the Msg service.
    #[derive(Debug)]
    pub struct MsgServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> MsgServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for MsgServer<T>
    where
        T: Msg,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/neutron.dex.Msg/Deposit" => {
                    #[allow(non_camel_case_types)]
                    struct DepositSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgDeposit>
                    for DepositSvc<T> {
                        type Response = super::MsgDepositResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgDeposit>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::deposit(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DepositSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Msg/Withdrawal" => {
                    #[allow(non_camel_case_types)]
                    struct WithdrawalSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgWithdrawal>
                    for WithdrawalSvc<T> {
                        type Response = super::MsgWithdrawalResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgWithdrawal>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::withdrawal(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = WithdrawalSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Msg/PlaceLimitOrder" => {
                    #[allow(non_camel_case_types)]
                    struct PlaceLimitOrderSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgPlaceLimitOrder>
                    for PlaceLimitOrderSvc<T> {
                        type Response = super::MsgPlaceLimitOrderResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgPlaceLimitOrder>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::place_limit_order(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PlaceLimitOrderSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Msg/WithdrawFilledLimitOrder" => {
                    #[allow(non_camel_case_types)]
                    struct WithdrawFilledLimitOrderSvc<T: Msg>(pub Arc<T>);
                    impl<
                        T: Msg,
                    > tonic::server::UnaryService<super::MsgWithdrawFilledLimitOrder>
                    for WithdrawFilledLimitOrderSvc<T> {
                        type Response = super::MsgWithdrawFilledLimitOrderResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgWithdrawFilledLimitOrder>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::withdraw_filled_limit_order(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = WithdrawFilledLimitOrderSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Msg/CancelLimitOrder" => {
                    #[allow(non_camel_case_types)]
                    struct CancelLimitOrderSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgCancelLimitOrder>
                    for CancelLimitOrderSvc<T> {
                        type Response = super::MsgCancelLimitOrderResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgCancelLimitOrder>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::cancel_limit_order(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CancelLimitOrderSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Msg/MultiHopSwap" => {
                    #[allow(non_camel_case_types)]
                    struct MultiHopSwapSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgMultiHopSwap>
                    for MultiHopSwapSvc<T> {
                        type Response = super::MsgMultiHopSwapResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgMultiHopSwap>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::multi_hop_swap(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = MultiHopSwapSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Msg/UpdateParams" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateParamsSvc<T: Msg>(pub Arc<T>);
                    impl<T: Msg> tonic::server::UnaryService<super::MsgUpdateParams>
                    for UpdateParamsSvc<T> {
                        type Response = super::MsgUpdateParamsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MsgUpdateParams>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Msg>::update_params(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateParamsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for MsgServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "neutron.dex.Msg";
    impl<T> tonic::server::NamedService for MsgServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LimitOrderExpiration {
    /// see limitOrderTranche.proto for details on expiration_time
    #[prost(message, optional, tag = "1")]
    pub expiration_time: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    #[prost(bytes = "vec", tag = "2")]
    pub tranche_ref: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for LimitOrderExpiration {
    const NAME: &'static str = "LimitOrderExpiration";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.LimitOrderExpiration".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.LimitOrderExpiration".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TradePairId {
    #[prost(string, tag = "2")]
    pub maker_denom: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub taker_denom: ::prost::alloc::string::String,
}
impl ::prost::Name for TradePairId {
    const NAME: &'static str = "TradePairID";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.TradePairID".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.TradePairID".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PoolReservesKey {
    #[prost(message, optional, tag = "1")]
    pub trade_pair_id: ::core::option::Option<TradePairId>,
    #[prost(int64, tag = "2")]
    pub tick_index_taker_to_maker: i64,
    #[prost(uint64, tag = "3")]
    pub fee: u64,
}
impl ::prost::Name for PoolReservesKey {
    const NAME: &'static str = "PoolReservesKey";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.PoolReservesKey".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.PoolReservesKey".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PoolReserves {
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<PoolReservesKey>,
    #[prost(string, tag = "2")]
    pub reserves_maker_denom: ::prost::alloc::string::String,
    /// DEPRECATED: price_taker_to_maker will be removed in future release, `maker_price` should always be used.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub price_taker_to_maker: ::prost::alloc::string::String,
    /// DEPRECATED: price_opposite_taker_maker was an internal implementation detail and will be removed in a future release.
    /// It is being kept strictly for backwards compatibility. The actual field value is unused.
    #[deprecated]
    #[prost(string, tag = "4")]
    pub price_opposite_taker_to_maker: ::prost::alloc::string::String,
    /// This is the price of the PoolReserves denominated in the opposite token. (ie. 1 TokenA with a maker_price of 10 is worth 10 TokenB )
    #[prost(string, tag = "5")]
    pub maker_price: ::prost::alloc::string::String,
}
impl ::prost::Name for PoolReserves {
    const NAME: &'static str = "PoolReserves";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.PoolReserves".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.PoolReserves".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Pool {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    #[prost(message, optional, tag = "2")]
    pub lower_tick0: ::core::option::Option<PoolReserves>,
    #[prost(message, optional, tag = "3")]
    pub upper_tick1: ::core::option::Option<PoolReserves>,
}
impl ::prost::Name for Pool {
    const NAME: &'static str = "Pool";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.Pool".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.Pool".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PairId {
    #[prost(string, tag = "1")]
    pub token0: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub token1: ::prost::alloc::string::String,
}
impl ::prost::Name for PairId {
    const NAME: &'static str = "PairID";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.PairID".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.PairID".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PoolMetadata {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    #[prost(int64, tag = "2")]
    pub tick: i64,
    #[prost(uint64, tag = "3")]
    pub fee: u64,
    #[prost(message, optional, tag = "4")]
    pub pair_id: ::core::option::Option<PairId>,
}
impl ::prost::Name for PoolMetadata {
    const NAME: &'static str = "PoolMetadata";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.PoolMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.PoolMetadata".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LimitOrderTrancheKey {
    #[prost(message, optional, tag = "1")]
    pub trade_pair_id: ::core::option::Option<TradePairId>,
    #[prost(int64, tag = "2")]
    pub tick_index_taker_to_maker: i64,
    #[prost(string, tag = "3")]
    pub tranche_key: ::prost::alloc::string::String,
}
impl ::prost::Name for LimitOrderTrancheKey {
    const NAME: &'static str = "LimitOrderTrancheKey";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.LimitOrderTrancheKey".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.LimitOrderTrancheKey".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LimitOrderTranche {
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<LimitOrderTrancheKey>,
    #[prost(string, tag = "2")]
    pub reserves_maker_denom: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub reserves_taker_denom: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub total_maker_denom: ::prost::alloc::string::String,
    /// LimitOrders with expiration_time set are valid as long as blockTime \<= expiration_time
    #[prost(string, tag = "5")]
    pub total_taker_denom: ::prost::alloc::string::String,
    /// JIT orders also use expiration_time to handle deletion but represent a special case
    /// All JIT orders have a expiration_time of 0 and an exception is made to still treat these orders as live
    /// Order deletion still functions the same and the orders will be deleted at the end of the block
    #[prost(message, optional, tag = "6")]
    pub expiration_time: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    /// DEPRECATED: price_taker_to_maker will be removed in future release, `maker_price` should always be used.
    #[deprecated]
    #[prost(string, tag = "7")]
    pub price_taker_to_maker: ::prost::alloc::string::String,
    /// This is the price of the LimitOrder denominated in the opposite token. (ie. 1 TokenA with a maker_price of 10 is worth 10 TokenB )
    #[prost(string, tag = "8")]
    pub maker_price: ::prost::alloc::string::String,
}
impl ::prost::Name for LimitOrderTranche {
    const NAME: &'static str = "LimitOrderTranche";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.LimitOrderTranche".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.LimitOrderTranche".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TickLiquidity {
    #[prost(oneof = "tick_liquidity::Liquidity", tags = "1, 2")]
    pub liquidity: ::core::option::Option<tick_liquidity::Liquidity>,
}
/// Nested message and enum types in `TickLiquidity`.
pub mod tick_liquidity {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Liquidity {
        #[prost(message, tag = "1")]
        PoolReserves(super::PoolReserves),
        #[prost(message, tag = "2")]
        LimitOrderTranche(super::LimitOrderTranche),
    }
}
impl ::prost::Name for TickLiquidity {
    const NAME: &'static str = "TickLiquidity";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.TickLiquidity".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.TickLiquidity".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DepositRecord {
    #[prost(message, optional, tag = "1")]
    pub pair_id: ::core::option::Option<PairId>,
    #[prost(string, tag = "2")]
    pub shares_owned: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub center_tick_index: i64,
    #[prost(int64, tag = "4")]
    pub lower_tick_index: i64,
    #[prost(int64, tag = "5")]
    pub upper_tick_index: i64,
    #[prost(uint64, tag = "6")]
    pub fee: u64,
    #[prost(string, tag = "7")]
    pub total_shares: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub pool: ::core::option::Option<Pool>,
}
impl ::prost::Name for DepositRecord {
    const NAME: &'static str = "DepositRecord";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.DepositRecord".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.DepositRecord".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LimitOrderTrancheUser {
    #[prost(message, optional, tag = "1")]
    pub trade_pair_id: ::core::option::Option<TradePairId>,
    #[prost(int64, tag = "2")]
    pub tick_index_taker_to_maker: i64,
    #[prost(string, tag = "3")]
    pub tranche_key: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub shares_owned: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub shares_withdrawn: ::prost::alloc::string::String,
    /// TODO: remove this in next release. It is no longer used
    #[prost(string, tag = "7")]
    pub shares_cancelled: ::prost::alloc::string::String,
    #[prost(enumeration = "LimitOrderType", tag = "8")]
    pub order_type: i32,
}
impl ::prost::Name for LimitOrderTrancheUser {
    const NAME: &'static str = "LimitOrderTrancheUser";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.LimitOrderTrancheUser".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.LimitOrderTrancheUser".into()
    }
}
/// QueryParamsRequest is request type for the Query/Params RPC method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryParamsRequest {}
impl ::prost::Name for QueryParamsRequest {
    const NAME: &'static str = "QueryParamsRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryParamsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryParamsRequest".into()
    }
}
/// QueryParamsResponse is response type for the Query/Params RPC method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryParamsResponse {
    /// params holds all the parameters of this module.
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for QueryParamsResponse {
    const NAME: &'static str = "QueryParamsResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryParamsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryParamsResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryGetLimitOrderTrancheUserRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tranche_key: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub calc_withdrawable_shares: bool,
}
impl ::prost::Name for QueryGetLimitOrderTrancheUserRequest {
    const NAME: &'static str = "QueryGetLimitOrderTrancheUserRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryGetLimitOrderTrancheUserRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryGetLimitOrderTrancheUserRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryGetLimitOrderTrancheUserResponse {
    #[prost(message, optional, tag = "1")]
    pub limit_order_tranche_user: ::core::option::Option<LimitOrderTrancheUser>,
    #[prost(string, tag = "2")]
    pub withdrawable_shares: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryGetLimitOrderTrancheUserResponse {
    const NAME: &'static str = "QueryGetLimitOrderTrancheUserResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryGetLimitOrderTrancheUserResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryGetLimitOrderTrancheUserResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryAllLimitOrderTrancheUserRequest {
    #[prost(message, optional, tag = "1")]
    pub pagination: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
impl ::prost::Name for QueryAllLimitOrderTrancheUserRequest {
    const NAME: &'static str = "QueryAllLimitOrderTrancheUserRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryAllLimitOrderTrancheUserRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryAllLimitOrderTrancheUserRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllLimitOrderTrancheUserResponse {
    #[prost(message, repeated, tag = "1")]
    pub limit_order_tranche_user: ::prost::alloc::vec::Vec<LimitOrderTrancheUser>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
impl ::prost::Name for QueryAllLimitOrderTrancheUserResponse {
    const NAME: &'static str = "QueryAllLimitOrderTrancheUserResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryAllLimitOrderTrancheUserResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryAllLimitOrderTrancheUserResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryGetLimitOrderTrancheRequest {
    #[prost(string, tag = "1")]
    pub pair_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub tick_index: i64,
    #[prost(string, tag = "3")]
    pub token_in: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub tranche_key: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryGetLimitOrderTrancheRequest {
    const NAME: &'static str = "QueryGetLimitOrderTrancheRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryGetLimitOrderTrancheRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryGetLimitOrderTrancheRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryGetLimitOrderTrancheResponse {
    #[prost(message, optional, tag = "1")]
    pub limit_order_tranche: ::core::option::Option<LimitOrderTranche>,
}
impl ::prost::Name for QueryGetLimitOrderTrancheResponse {
    const NAME: &'static str = "QueryGetLimitOrderTrancheResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryGetLimitOrderTrancheResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryGetLimitOrderTrancheResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryAllLimitOrderTrancheRequest {
    #[prost(string, tag = "1")]
    pub pair_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub token_in: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub pagination: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
impl ::prost::Name for QueryAllLimitOrderTrancheRequest {
    const NAME: &'static str = "QueryAllLimitOrderTrancheRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryAllLimitOrderTrancheRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryAllLimitOrderTrancheRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllLimitOrderTrancheResponse {
    #[prost(message, repeated, tag = "1")]
    pub limit_order_tranche: ::prost::alloc::vec::Vec<LimitOrderTranche>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
impl ::prost::Name for QueryAllLimitOrderTrancheResponse {
    const NAME: &'static str = "QueryAllLimitOrderTrancheResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryAllLimitOrderTrancheResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryAllLimitOrderTrancheResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryAllUserDepositsRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
    #[prost(bool, tag = "3")]
    pub include_pool_data: bool,
}
impl ::prost::Name for QueryAllUserDepositsRequest {
    const NAME: &'static str = "QueryAllUserDepositsRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryAllUserDepositsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryAllUserDepositsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllUserDepositsResponse {
    #[prost(message, repeated, tag = "1")]
    pub deposits: ::prost::alloc::vec::Vec<DepositRecord>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
impl ::prost::Name for QueryAllUserDepositsResponse {
    const NAME: &'static str = "QueryAllUserDepositsResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryAllUserDepositsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryAllUserDepositsResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryAllLimitOrderTrancheUserByAddressRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
impl ::prost::Name for QueryAllLimitOrderTrancheUserByAddressRequest {
    const NAME: &'static str = "QueryAllLimitOrderTrancheUserByAddressRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryAllLimitOrderTrancheUserByAddressRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryAllLimitOrderTrancheUserByAddressRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllLimitOrderTrancheUserByAddressResponse {
    #[prost(message, repeated, tag = "1")]
    pub limit_orders: ::prost::alloc::vec::Vec<LimitOrderTrancheUser>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
impl ::prost::Name for QueryAllLimitOrderTrancheUserByAddressResponse {
    const NAME: &'static str = "QueryAllLimitOrderTrancheUserByAddressResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryAllLimitOrderTrancheUserByAddressResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryAllLimitOrderTrancheUserByAddressResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryAllTickLiquidityRequest {
    #[prost(string, tag = "1")]
    pub pair_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub token_in: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub pagination: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
impl ::prost::Name for QueryAllTickLiquidityRequest {
    const NAME: &'static str = "QueryAllTickLiquidityRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryAllTickLiquidityRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryAllTickLiquidityRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllTickLiquidityResponse {
    #[prost(message, repeated, tag = "1")]
    pub tick_liquidity: ::prost::alloc::vec::Vec<TickLiquidity>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
impl ::prost::Name for QueryAllTickLiquidityResponse {
    const NAME: &'static str = "QueryAllTickLiquidityResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryAllTickLiquidityResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryAllTickLiquidityResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryGetInactiveLimitOrderTrancheRequest {
    #[prost(string, tag = "1")]
    pub pair_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub token_in: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub tick_index: i64,
    #[prost(string, tag = "4")]
    pub tranche_key: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryGetInactiveLimitOrderTrancheRequest {
    const NAME: &'static str = "QueryGetInactiveLimitOrderTrancheRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryGetInactiveLimitOrderTrancheRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryGetInactiveLimitOrderTrancheRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryGetInactiveLimitOrderTrancheResponse {
    #[prost(message, optional, tag = "1")]
    pub inactive_limit_order_tranche: ::core::option::Option<LimitOrderTranche>,
}
impl ::prost::Name for QueryGetInactiveLimitOrderTrancheResponse {
    const NAME: &'static str = "QueryGetInactiveLimitOrderTrancheResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryGetInactiveLimitOrderTrancheResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryGetInactiveLimitOrderTrancheResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryAllInactiveLimitOrderTrancheRequest {
    #[prost(message, optional, tag = "1")]
    pub pagination: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
impl ::prost::Name for QueryAllInactiveLimitOrderTrancheRequest {
    const NAME: &'static str = "QueryAllInactiveLimitOrderTrancheRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryAllInactiveLimitOrderTrancheRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryAllInactiveLimitOrderTrancheRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllInactiveLimitOrderTrancheResponse {
    #[prost(message, repeated, tag = "1")]
    pub inactive_limit_order_tranche: ::prost::alloc::vec::Vec<LimitOrderTranche>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
impl ::prost::Name for QueryAllInactiveLimitOrderTrancheResponse {
    const NAME: &'static str = "QueryAllInactiveLimitOrderTrancheResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryAllInactiveLimitOrderTrancheResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryAllInactiveLimitOrderTrancheResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryAllPoolReservesRequest {
    #[prost(string, tag = "1")]
    pub pair_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub token_in: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub pagination: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
impl ::prost::Name for QueryAllPoolReservesRequest {
    const NAME: &'static str = "QueryAllPoolReservesRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryAllPoolReservesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryAllPoolReservesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllPoolReservesResponse {
    #[prost(message, repeated, tag = "1")]
    pub pool_reserves: ::prost::alloc::vec::Vec<PoolReserves>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
impl ::prost::Name for QueryAllPoolReservesResponse {
    const NAME: &'static str = "QueryAllPoolReservesResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryAllPoolReservesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryAllPoolReservesResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryGetPoolReservesRequest {
    #[prost(string, tag = "1")]
    pub pair_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub token_in: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub tick_index: i64,
    #[prost(uint64, tag = "4")]
    pub fee: u64,
}
impl ::prost::Name for QueryGetPoolReservesRequest {
    const NAME: &'static str = "QueryGetPoolReservesRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryGetPoolReservesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryGetPoolReservesRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryGetPoolReservesResponse {
    #[prost(message, optional, tag = "1")]
    pub pool_reserves: ::core::option::Option<PoolReserves>,
}
impl ::prost::Name for QueryGetPoolReservesResponse {
    const NAME: &'static str = "QueryGetPoolReservesResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryGetPoolReservesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryGetPoolReservesResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryEstimateMultiHopSwapRequest {
    /// DEPRECATED: Use QuerySimulateMultiHopSwap
    #[prost(string, tag = "1")]
    pub creator: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub receiver: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub routes: ::prost::alloc::vec::Vec<MultiHopRoute>,
    #[prost(string, tag = "4")]
    pub amount_in: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub exit_limit_price: ::prost::alloc::string::String,
    /// If pickBestRoute == true then all routes are run and the route with the
    /// best price is chosen otherwise, the first succesful route is used.
    #[prost(bool, tag = "6")]
    pub pick_best_route: bool,
}
impl ::prost::Name for QueryEstimateMultiHopSwapRequest {
    const NAME: &'static str = "QueryEstimateMultiHopSwapRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryEstimateMultiHopSwapRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryEstimateMultiHopSwapRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryEstimateMultiHopSwapResponse {
    #[prost(message, optional, tag = "1")]
    pub coin_out: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
impl ::prost::Name for QueryEstimateMultiHopSwapResponse {
    const NAME: &'static str = "QueryEstimateMultiHopSwapResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryEstimateMultiHopSwapResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryEstimateMultiHopSwapResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryEstimatePlaceLimitOrderRequest {
    /// DEPRECATED: Use QuerySimulatePlaceLimitOrder
    #[prost(string, tag = "1")]
    pub creator: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub receiver: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub token_in: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub token_out: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub tick_index_in_to_out: i64,
    #[prost(string, tag = "6")]
    pub amount_in: ::prost::alloc::string::String,
    #[prost(enumeration = "LimitOrderType", tag = "7")]
    pub order_type: i32,
    /// expirationTime is only valid iff orderType == GOOD_TIL_TIME.
    #[prost(message, optional, tag = "8")]
    pub expiration_time: ::core::option::Option<
        ::tendermint_proto::google::protobuf::Timestamp,
    >,
    #[prost(string, tag = "9")]
    pub max_amount_out: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryEstimatePlaceLimitOrderRequest {
    const NAME: &'static str = "QueryEstimatePlaceLimitOrderRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryEstimatePlaceLimitOrderRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryEstimatePlaceLimitOrderRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryEstimatePlaceLimitOrderResponse {
    /// Total amount of coin used for the limit order
    /// You can derive makerLimitInCoin using the equation: totalInCoin =
    /// swapInCoin + makerLimitInCoin
    #[prost(message, optional, tag = "1")]
    pub total_in_coin: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// Total amount of the token in that was immediately swapped for swapOutCoin
    #[prost(message, optional, tag = "2")]
    pub swap_in_coin: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
    /// Total amount of coin received from the taker portion of the limit order
    /// This is the amount of coin immediately available in the users account after
    /// executing the limit order. It does not include any future proceeds from the
    /// maker portion which will have withdrawn in the future
    #[prost(message, optional, tag = "3")]
    pub swap_out_coin: ::core::option::Option<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
impl ::prost::Name for QueryEstimatePlaceLimitOrderResponse {
    const NAME: &'static str = "QueryEstimatePlaceLimitOrderResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryEstimatePlaceLimitOrderResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryEstimatePlaceLimitOrderResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryPoolRequest {
    #[prost(string, tag = "1")]
    pub pair_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub tick_index: i64,
    #[prost(uint64, tag = "3")]
    pub fee: u64,
}
impl ::prost::Name for QueryPoolRequest {
    const NAME: &'static str = "QueryPoolRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryPoolRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryPoolRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryPoolByIdRequest {
    #[prost(uint64, tag = "1")]
    pub pool_id: u64,
}
impl ::prost::Name for QueryPoolByIdRequest {
    const NAME: &'static str = "QueryPoolByIDRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryPoolByIDRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryPoolByIDRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryPoolResponse {
    #[prost(message, optional, tag = "1")]
    pub pool: ::core::option::Option<Pool>,
}
impl ::prost::Name for QueryPoolResponse {
    const NAME: &'static str = "QueryPoolResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryPoolResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryPoolResponse".into()
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryGetPoolMetadataRequest {
    #[prost(uint64, tag = "1")]
    pub id: u64,
}
impl ::prost::Name for QueryGetPoolMetadataRequest {
    const NAME: &'static str = "QueryGetPoolMetadataRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryGetPoolMetadataRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryGetPoolMetadataRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryGetPoolMetadataResponse {
    #[prost(message, optional, tag = "1")]
    pub pool_metadata: ::core::option::Option<PoolMetadata>,
}
impl ::prost::Name for QueryGetPoolMetadataResponse {
    const NAME: &'static str = "QueryGetPoolMetadataResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryGetPoolMetadataResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryGetPoolMetadataResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryAllPoolMetadataRequest {
    #[prost(message, optional, tag = "1")]
    pub pagination: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest,
    >,
}
impl ::prost::Name for QueryAllPoolMetadataRequest {
    const NAME: &'static str = "QueryAllPoolMetadataRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryAllPoolMetadataRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryAllPoolMetadataRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllPoolMetadataResponse {
    #[prost(message, repeated, tag = "1")]
    pub pool_metadata: ::prost::alloc::vec::Vec<PoolMetadata>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse,
    >,
}
impl ::prost::Name for QueryAllPoolMetadataResponse {
    const NAME: &'static str = "QueryAllPoolMetadataResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QueryAllPoolMetadataResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QueryAllPoolMetadataResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySimulateDepositRequest {
    #[prost(message, optional, tag = "1")]
    pub msg: ::core::option::Option<MsgDeposit>,
}
impl ::prost::Name for QuerySimulateDepositRequest {
    const NAME: &'static str = "QuerySimulateDepositRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QuerySimulateDepositRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QuerySimulateDepositRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySimulateDepositResponse {
    #[prost(message, optional, tag = "1")]
    pub resp: ::core::option::Option<MsgDepositResponse>,
}
impl ::prost::Name for QuerySimulateDepositResponse {
    const NAME: &'static str = "QuerySimulateDepositResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QuerySimulateDepositResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QuerySimulateDepositResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QuerySimulateWithdrawalRequest {
    #[prost(message, optional, tag = "1")]
    pub msg: ::core::option::Option<MsgWithdrawal>,
}
impl ::prost::Name for QuerySimulateWithdrawalRequest {
    const NAME: &'static str = "QuerySimulateWithdrawalRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QuerySimulateWithdrawalRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QuerySimulateWithdrawalRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySimulateWithdrawalResponse {
    #[prost(message, optional, tag = "1")]
    pub resp: ::core::option::Option<MsgWithdrawalResponse>,
}
impl ::prost::Name for QuerySimulateWithdrawalResponse {
    const NAME: &'static str = "QuerySimulateWithdrawalResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QuerySimulateWithdrawalResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QuerySimulateWithdrawalResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QuerySimulatePlaceLimitOrderRequest {
    #[prost(message, optional, tag = "1")]
    pub msg: ::core::option::Option<MsgPlaceLimitOrder>,
}
impl ::prost::Name for QuerySimulatePlaceLimitOrderRequest {
    const NAME: &'static str = "QuerySimulatePlaceLimitOrderRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QuerySimulatePlaceLimitOrderRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QuerySimulatePlaceLimitOrderRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QuerySimulatePlaceLimitOrderResponse {
    #[prost(message, optional, tag = "1")]
    pub resp: ::core::option::Option<MsgPlaceLimitOrderResponse>,
}
impl ::prost::Name for QuerySimulatePlaceLimitOrderResponse {
    const NAME: &'static str = "QuerySimulatePlaceLimitOrderResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QuerySimulatePlaceLimitOrderResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QuerySimulatePlaceLimitOrderResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QuerySimulateWithdrawFilledLimitOrderRequest {
    #[prost(message, optional, tag = "1")]
    pub msg: ::core::option::Option<MsgWithdrawFilledLimitOrder>,
}
impl ::prost::Name for QuerySimulateWithdrawFilledLimitOrderRequest {
    const NAME: &'static str = "QuerySimulateWithdrawFilledLimitOrderRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QuerySimulateWithdrawFilledLimitOrderRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QuerySimulateWithdrawFilledLimitOrderRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QuerySimulateWithdrawFilledLimitOrderResponse {
    #[prost(message, optional, tag = "1")]
    pub resp: ::core::option::Option<MsgWithdrawFilledLimitOrderResponse>,
}
impl ::prost::Name for QuerySimulateWithdrawFilledLimitOrderResponse {
    const NAME: &'static str = "QuerySimulateWithdrawFilledLimitOrderResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QuerySimulateWithdrawFilledLimitOrderResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QuerySimulateWithdrawFilledLimitOrderResponse".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QuerySimulateCancelLimitOrderRequest {
    #[prost(message, optional, tag = "1")]
    pub msg: ::core::option::Option<MsgCancelLimitOrder>,
}
impl ::prost::Name for QuerySimulateCancelLimitOrderRequest {
    const NAME: &'static str = "QuerySimulateCancelLimitOrderRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QuerySimulateCancelLimitOrderRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QuerySimulateCancelLimitOrderRequest".into()
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QuerySimulateCancelLimitOrderResponse {
    #[prost(message, optional, tag = "1")]
    pub resp: ::core::option::Option<MsgCancelLimitOrderResponse>,
}
impl ::prost::Name for QuerySimulateCancelLimitOrderResponse {
    const NAME: &'static str = "QuerySimulateCancelLimitOrderResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QuerySimulateCancelLimitOrderResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QuerySimulateCancelLimitOrderResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySimulateMultiHopSwapRequest {
    #[prost(message, optional, tag = "1")]
    pub msg: ::core::option::Option<MsgMultiHopSwap>,
}
impl ::prost::Name for QuerySimulateMultiHopSwapRequest {
    const NAME: &'static str = "QuerySimulateMultiHopSwapRequest";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QuerySimulateMultiHopSwapRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QuerySimulateMultiHopSwapRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySimulateMultiHopSwapResponse {
    #[prost(message, optional, tag = "1")]
    pub resp: ::core::option::Option<MsgMultiHopSwapResponse>,
}
impl ::prost::Name for QuerySimulateMultiHopSwapResponse {
    const NAME: &'static str = "QuerySimulateMultiHopSwapResponse";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.QuerySimulateMultiHopSwapResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.QuerySimulateMultiHopSwapResponse".into()
    }
}
/// Generated client implementations.
#[cfg(feature = "client")]
pub mod query_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Query defines the gRPC querier service.
    #[derive(Debug, Clone)]
    pub struct QueryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    #[cfg(feature = "transport")]
    impl QueryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> QueryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> QueryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            QueryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Parameters queries the parameters of the module.
        pub async fn params(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryParamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/neutron.dex.Query/Params");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("neutron.dex.Query", "Params"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries a LimitOrderTrancheUser by index.
        pub async fn limit_order_tranche_user(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetLimitOrderTrancheUserRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetLimitOrderTrancheUserResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/LimitOrderTrancheUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Query", "LimitOrderTrancheUser"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries a list of LimitOrderTranchUser items.
        pub async fn limit_order_tranche_user_all(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAllLimitOrderTrancheUserRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllLimitOrderTrancheUserResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/LimitOrderTrancheUserAll",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("neutron.dex.Query", "LimitOrderTrancheUserAll"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Queries a list of LimitOrderTrancheUser items for a given address.
        pub async fn limit_order_tranche_user_all_by_address(
            &mut self,
            request: impl tonic::IntoRequest<
                super::QueryAllLimitOrderTrancheUserByAddressRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllLimitOrderTrancheUserByAddressResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/LimitOrderTrancheUserAllByAddress",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "neutron.dex.Query",
                        "LimitOrderTrancheUserAllByAddress",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Queries a LimitOrderTranche by index.
        pub async fn limit_order_tranche(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetLimitOrderTrancheRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetLimitOrderTrancheResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/LimitOrderTranche",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Query", "LimitOrderTranche"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries a list of LimitOrderTranche items for a given pairID / TokenIn
        /// combination.
        pub async fn limit_order_tranche_all(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAllLimitOrderTrancheRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllLimitOrderTrancheResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/LimitOrderTrancheAll",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Query", "LimitOrderTrancheAll"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries a list of UserDeposits items.
        pub async fn user_deposits_all(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAllUserDepositsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllUserDepositsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/UserDepositsAll",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Query", "UserDepositsAll"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries a list of TickLiquidity items.
        pub async fn tick_liquidity_all(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAllTickLiquidityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllTickLiquidityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/TickLiquidityAll",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Query", "TickLiquidityAll"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries a InactiveLimitOrderTranche by index.
        pub async fn inactive_limit_order_tranche(
            &mut self,
            request: impl tonic::IntoRequest<
                super::QueryGetInactiveLimitOrderTrancheRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetInactiveLimitOrderTrancheResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/InactiveLimitOrderTranche",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("neutron.dex.Query", "InactiveLimitOrderTranche"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Queries a list of InactiveLimitOrderTranche items.
        pub async fn inactive_limit_order_tranche_all(
            &mut self,
            request: impl tonic::IntoRequest<
                super::QueryAllInactiveLimitOrderTrancheRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllInactiveLimitOrderTrancheResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/InactiveLimitOrderTrancheAll",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("neutron.dex.Query", "InactiveLimitOrderTrancheAll"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Queries a list of PoolReserves items.
        pub async fn pool_reserves_all(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAllPoolReservesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllPoolReservesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/PoolReservesAll",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Query", "PoolReservesAll"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries a PoolReserve by index
        pub async fn pool_reserves(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetPoolReservesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetPoolReservesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/PoolReserves",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Query", "PoolReserves"));
            self.inner.unary(req, path, codec).await
        }
        /// DEPRECATED Queries the simulated result of a multihop swap
        #[deprecated]
        pub async fn estimate_multi_hop_swap(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryEstimateMultiHopSwapRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryEstimateMultiHopSwapResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/EstimateMultiHopSwap",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Query", "EstimateMultiHopSwap"));
            self.inner.unary(req, path, codec).await
        }
        /// DEPRECATED Queries the simulated result of a PlaceLimit order
        #[deprecated]
        pub async fn estimate_place_limit_order(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryEstimatePlaceLimitOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryEstimatePlaceLimitOrderResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/EstimatePlaceLimitOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Query", "EstimatePlaceLimitOrder"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries a pool by pair, tick and fee
        pub async fn pool(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryPoolRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryPoolResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/neutron.dex.Query/Pool");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("neutron.dex.Query", "Pool"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries a pool by ID
        pub async fn pool_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryPoolByIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryPoolResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/PoolByID",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Query", "PoolByID"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries a PoolMetadata by ID
        pub async fn pool_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetPoolMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetPoolMetadataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/PoolMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Query", "PoolMetadata"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries a list of PoolMetadata items.
        pub async fn pool_metadata_all(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAllPoolMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllPoolMetadataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/PoolMetadataAll",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Query", "PoolMetadataAll"));
            self.inner.unary(req, path, codec).await
        }
        /// Simulates MsgDeposit
        pub async fn simulate_deposit(
            &mut self,
            request: impl tonic::IntoRequest<super::QuerySimulateDepositRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QuerySimulateDepositResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/SimulateDeposit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Query", "SimulateDeposit"));
            self.inner.unary(req, path, codec).await
        }
        /// Simulates MsgWithdrawal
        pub async fn simulate_withdrawal(
            &mut self,
            request: impl tonic::IntoRequest<super::QuerySimulateWithdrawalRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QuerySimulateWithdrawalResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/SimulateWithdrawal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Query", "SimulateWithdrawal"));
            self.inner.unary(req, path, codec).await
        }
        /// Simulates MsgPlaceLimitOrder
        pub async fn simulate_place_limit_order(
            &mut self,
            request: impl tonic::IntoRequest<super::QuerySimulatePlaceLimitOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QuerySimulatePlaceLimitOrderResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/SimulatePlaceLimitOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Query", "SimulatePlaceLimitOrder"));
            self.inner.unary(req, path, codec).await
        }
        /// Simulates MsgWithdrawFilledLimitOrder
        pub async fn simulate_withdraw_filled_limit_order(
            &mut self,
            request: impl tonic::IntoRequest<
                super::QuerySimulateWithdrawFilledLimitOrderRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::QuerySimulateWithdrawFilledLimitOrderResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/SimulateWithdrawFilledLimitOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "neutron.dex.Query",
                        "SimulateWithdrawFilledLimitOrder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Simulates MsgCancelLimitOrder
        pub async fn simulate_cancel_limit_order(
            &mut self,
            request: impl tonic::IntoRequest<super::QuerySimulateCancelLimitOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QuerySimulateCancelLimitOrderResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/SimulateCancelLimitOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("neutron.dex.Query", "SimulateCancelLimitOrder"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Simulates MsgMultiHopSwap
        pub async fn simulate_multi_hop_swap(
            &mut self,
            request: impl tonic::IntoRequest<super::QuerySimulateMultiHopSwapRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QuerySimulateMultiHopSwapResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/neutron.dex.Query/SimulateMultiHopSwap",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("neutron.dex.Query", "SimulateMultiHopSwap"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
#[cfg(feature = "server")]
pub mod query_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with QueryServer.
    #[async_trait]
    pub trait Query: std::marker::Send + std::marker::Sync + 'static {
        /// Parameters queries the parameters of the module.
        async fn params(
            &self,
            request: tonic::Request<super::QueryParamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryParamsResponse>,
            tonic::Status,
        >;
        /// Queries a LimitOrderTrancheUser by index.
        async fn limit_order_tranche_user(
            &self,
            request: tonic::Request<super::QueryGetLimitOrderTrancheUserRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetLimitOrderTrancheUserResponse>,
            tonic::Status,
        >;
        /// Queries a list of LimitOrderTranchUser items.
        async fn limit_order_tranche_user_all(
            &self,
            request: tonic::Request<super::QueryAllLimitOrderTrancheUserRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllLimitOrderTrancheUserResponse>,
            tonic::Status,
        >;
        /// Queries a list of LimitOrderTrancheUser items for a given address.
        async fn limit_order_tranche_user_all_by_address(
            &self,
            request: tonic::Request<super::QueryAllLimitOrderTrancheUserByAddressRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllLimitOrderTrancheUserByAddressResponse>,
            tonic::Status,
        >;
        /// Queries a LimitOrderTranche by index.
        async fn limit_order_tranche(
            &self,
            request: tonic::Request<super::QueryGetLimitOrderTrancheRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetLimitOrderTrancheResponse>,
            tonic::Status,
        >;
        /// Queries a list of LimitOrderTranche items for a given pairID / TokenIn
        /// combination.
        async fn limit_order_tranche_all(
            &self,
            request: tonic::Request<super::QueryAllLimitOrderTrancheRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllLimitOrderTrancheResponse>,
            tonic::Status,
        >;
        /// Queries a list of UserDeposits items.
        async fn user_deposits_all(
            &self,
            request: tonic::Request<super::QueryAllUserDepositsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllUserDepositsResponse>,
            tonic::Status,
        >;
        /// Queries a list of TickLiquidity items.
        async fn tick_liquidity_all(
            &self,
            request: tonic::Request<super::QueryAllTickLiquidityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllTickLiquidityResponse>,
            tonic::Status,
        >;
        /// Queries a InactiveLimitOrderTranche by index.
        async fn inactive_limit_order_tranche(
            &self,
            request: tonic::Request<super::QueryGetInactiveLimitOrderTrancheRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetInactiveLimitOrderTrancheResponse>,
            tonic::Status,
        >;
        /// Queries a list of InactiveLimitOrderTranche items.
        async fn inactive_limit_order_tranche_all(
            &self,
            request: tonic::Request<super::QueryAllInactiveLimitOrderTrancheRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllInactiveLimitOrderTrancheResponse>,
            tonic::Status,
        >;
        /// Queries a list of PoolReserves items.
        async fn pool_reserves_all(
            &self,
            request: tonic::Request<super::QueryAllPoolReservesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllPoolReservesResponse>,
            tonic::Status,
        >;
        /// Queries a PoolReserve by index
        async fn pool_reserves(
            &self,
            request: tonic::Request<super::QueryGetPoolReservesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetPoolReservesResponse>,
            tonic::Status,
        >;
        /// DEPRECATED Queries the simulated result of a multihop swap
        async fn estimate_multi_hop_swap(
            &self,
            request: tonic::Request<super::QueryEstimateMultiHopSwapRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryEstimateMultiHopSwapResponse>,
            tonic::Status,
        >;
        /// DEPRECATED Queries the simulated result of a PlaceLimit order
        async fn estimate_place_limit_order(
            &self,
            request: tonic::Request<super::QueryEstimatePlaceLimitOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryEstimatePlaceLimitOrderResponse>,
            tonic::Status,
        >;
        /// Queries a pool by pair, tick and fee
        async fn pool(
            &self,
            request: tonic::Request<super::QueryPoolRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryPoolResponse>,
            tonic::Status,
        >;
        /// Queries a pool by ID
        async fn pool_by_id(
            &self,
            request: tonic::Request<super::QueryPoolByIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryPoolResponse>,
            tonic::Status,
        >;
        /// Queries a PoolMetadata by ID
        async fn pool_metadata(
            &self,
            request: tonic::Request<super::QueryGetPoolMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetPoolMetadataResponse>,
            tonic::Status,
        >;
        /// Queries a list of PoolMetadata items.
        async fn pool_metadata_all(
            &self,
            request: tonic::Request<super::QueryAllPoolMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllPoolMetadataResponse>,
            tonic::Status,
        >;
        /// Simulates MsgDeposit
        async fn simulate_deposit(
            &self,
            request: tonic::Request<super::QuerySimulateDepositRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QuerySimulateDepositResponse>,
            tonic::Status,
        >;
        /// Simulates MsgWithdrawal
        async fn simulate_withdrawal(
            &self,
            request: tonic::Request<super::QuerySimulateWithdrawalRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QuerySimulateWithdrawalResponse>,
            tonic::Status,
        >;
        /// Simulates MsgPlaceLimitOrder
        async fn simulate_place_limit_order(
            &self,
            request: tonic::Request<super::QuerySimulatePlaceLimitOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QuerySimulatePlaceLimitOrderResponse>,
            tonic::Status,
        >;
        /// Simulates MsgWithdrawFilledLimitOrder
        async fn simulate_withdraw_filled_limit_order(
            &self,
            request: tonic::Request<super::QuerySimulateWithdrawFilledLimitOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QuerySimulateWithdrawFilledLimitOrderResponse>,
            tonic::Status,
        >;
        /// Simulates MsgCancelLimitOrder
        async fn simulate_cancel_limit_order(
            &self,
            request: tonic::Request<super::QuerySimulateCancelLimitOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QuerySimulateCancelLimitOrderResponse>,
            tonic::Status,
        >;
        /// Simulates MsgMultiHopSwap
        async fn simulate_multi_hop_swap(
            &self,
            request: tonic::Request<super::QuerySimulateMultiHopSwapRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QuerySimulateMultiHopSwapResponse>,
            tonic::Status,
        >;
    }
    /// Query defines the gRPC querier service.
    #[derive(Debug)]
    pub struct QueryServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> QueryServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for QueryServer<T>
    where
        T: Query,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/neutron.dex.Query/Params" => {
                    #[allow(non_camel_case_types)]
                    struct ParamsSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryParamsRequest>
                    for ParamsSvc<T> {
                        type Response = super::QueryParamsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryParamsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::params(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ParamsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/LimitOrderTrancheUser" => {
                    #[allow(non_camel_case_types)]
                    struct LimitOrderTrancheUserSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryGetLimitOrderTrancheUserRequest,
                    > for LimitOrderTrancheUserSvc<T> {
                        type Response = super::QueryGetLimitOrderTrancheUserResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryGetLimitOrderTrancheUserRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::limit_order_tranche_user(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LimitOrderTrancheUserSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/LimitOrderTrancheUserAll" => {
                    #[allow(non_camel_case_types)]
                    struct LimitOrderTrancheUserAllSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryAllLimitOrderTrancheUserRequest,
                    > for LimitOrderTrancheUserAllSvc<T> {
                        type Response = super::QueryAllLimitOrderTrancheUserResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryAllLimitOrderTrancheUserRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::limit_order_tranche_user_all(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LimitOrderTrancheUserAllSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/LimitOrderTrancheUserAllByAddress" => {
                    #[allow(non_camel_case_types)]
                    struct LimitOrderTrancheUserAllByAddressSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryAllLimitOrderTrancheUserByAddressRequest,
                    > for LimitOrderTrancheUserAllByAddressSvc<T> {
                        type Response = super::QueryAllLimitOrderTrancheUserByAddressResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryAllLimitOrderTrancheUserByAddressRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::limit_order_tranche_user_all_by_address(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LimitOrderTrancheUserAllByAddressSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/LimitOrderTranche" => {
                    #[allow(non_camel_case_types)]
                    struct LimitOrderTrancheSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryGetLimitOrderTrancheRequest,
                    > for LimitOrderTrancheSvc<T> {
                        type Response = super::QueryGetLimitOrderTrancheResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryGetLimitOrderTrancheRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::limit_order_tranche(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LimitOrderTrancheSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/LimitOrderTrancheAll" => {
                    #[allow(non_camel_case_types)]
                    struct LimitOrderTrancheAllSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryAllLimitOrderTrancheRequest,
                    > for LimitOrderTrancheAllSvc<T> {
                        type Response = super::QueryAllLimitOrderTrancheResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryAllLimitOrderTrancheRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::limit_order_tranche_all(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LimitOrderTrancheAllSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/UserDepositsAll" => {
                    #[allow(non_camel_case_types)]
                    struct UserDepositsAllSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QueryAllUserDepositsRequest>
                    for UserDepositsAllSvc<T> {
                        type Response = super::QueryAllUserDepositsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryAllUserDepositsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::user_deposits_all(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UserDepositsAllSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/TickLiquidityAll" => {
                    #[allow(non_camel_case_types)]
                    struct TickLiquidityAllSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QueryAllTickLiquidityRequest>
                    for TickLiquidityAllSvc<T> {
                        type Response = super::QueryAllTickLiquidityResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryAllTickLiquidityRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::tick_liquidity_all(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TickLiquidityAllSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/InactiveLimitOrderTranche" => {
                    #[allow(non_camel_case_types)]
                    struct InactiveLimitOrderTrancheSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryGetInactiveLimitOrderTrancheRequest,
                    > for InactiveLimitOrderTrancheSvc<T> {
                        type Response = super::QueryGetInactiveLimitOrderTrancheResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryGetInactiveLimitOrderTrancheRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::inactive_limit_order_tranche(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InactiveLimitOrderTrancheSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/InactiveLimitOrderTrancheAll" => {
                    #[allow(non_camel_case_types)]
                    struct InactiveLimitOrderTrancheAllSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryAllInactiveLimitOrderTrancheRequest,
                    > for InactiveLimitOrderTrancheAllSvc<T> {
                        type Response = super::QueryAllInactiveLimitOrderTrancheResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryAllInactiveLimitOrderTrancheRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::inactive_limit_order_tranche_all(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InactiveLimitOrderTrancheAllSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/PoolReservesAll" => {
                    #[allow(non_camel_case_types)]
                    struct PoolReservesAllSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QueryAllPoolReservesRequest>
                    for PoolReservesAllSvc<T> {
                        type Response = super::QueryAllPoolReservesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryAllPoolReservesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::pool_reserves_all(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PoolReservesAllSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/PoolReserves" => {
                    #[allow(non_camel_case_types)]
                    struct PoolReservesSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QueryGetPoolReservesRequest>
                    for PoolReservesSvc<T> {
                        type Response = super::QueryGetPoolReservesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetPoolReservesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::pool_reserves(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PoolReservesSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/EstimateMultiHopSwap" => {
                    #[allow(non_camel_case_types)]
                    struct EstimateMultiHopSwapSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryEstimateMultiHopSwapRequest,
                    > for EstimateMultiHopSwapSvc<T> {
                        type Response = super::QueryEstimateMultiHopSwapResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryEstimateMultiHopSwapRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::estimate_multi_hop_swap(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EstimateMultiHopSwapSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/EstimatePlaceLimitOrder" => {
                    #[allow(non_camel_case_types)]
                    struct EstimatePlaceLimitOrderSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QueryEstimatePlaceLimitOrderRequest,
                    > for EstimatePlaceLimitOrderSvc<T> {
                        type Response = super::QueryEstimatePlaceLimitOrderResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QueryEstimatePlaceLimitOrderRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::estimate_place_limit_order(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = EstimatePlaceLimitOrderSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/Pool" => {
                    #[allow(non_camel_case_types)]
                    struct PoolSvc<T: Query>(pub Arc<T>);
                    impl<T: Query> tonic::server::UnaryService<super::QueryPoolRequest>
                    for PoolSvc<T> {
                        type Response = super::QueryPoolResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryPoolRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::pool(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PoolSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/PoolByID" => {
                    #[allow(non_camel_case_types)]
                    struct PoolByIDSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QueryPoolByIdRequest>
                    for PoolByIDSvc<T> {
                        type Response = super::QueryPoolResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryPoolByIdRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::pool_by_id(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PoolByIDSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/PoolMetadata" => {
                    #[allow(non_camel_case_types)]
                    struct PoolMetadataSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QueryGetPoolMetadataRequest>
                    for PoolMetadataSvc<T> {
                        type Response = super::QueryGetPoolMetadataResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryGetPoolMetadataRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::pool_metadata(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PoolMetadataSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/PoolMetadataAll" => {
                    #[allow(non_camel_case_types)]
                    struct PoolMetadataAllSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QueryAllPoolMetadataRequest>
                    for PoolMetadataAllSvc<T> {
                        type Response = super::QueryAllPoolMetadataResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryAllPoolMetadataRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::pool_metadata_all(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PoolMetadataAllSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/SimulateDeposit" => {
                    #[allow(non_camel_case_types)]
                    struct SimulateDepositSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QuerySimulateDepositRequest>
                    for SimulateDepositSvc<T> {
                        type Response = super::QuerySimulateDepositResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QuerySimulateDepositRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::simulate_deposit(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SimulateDepositSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/SimulateWithdrawal" => {
                    #[allow(non_camel_case_types)]
                    struct SimulateWithdrawalSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<super::QuerySimulateWithdrawalRequest>
                    for SimulateWithdrawalSvc<T> {
                        type Response = super::QuerySimulateWithdrawalResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QuerySimulateWithdrawalRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::simulate_withdrawal(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SimulateWithdrawalSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/SimulatePlaceLimitOrder" => {
                    #[allow(non_camel_case_types)]
                    struct SimulatePlaceLimitOrderSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QuerySimulatePlaceLimitOrderRequest,
                    > for SimulatePlaceLimitOrderSvc<T> {
                        type Response = super::QuerySimulatePlaceLimitOrderResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QuerySimulatePlaceLimitOrderRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::simulate_place_limit_order(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SimulatePlaceLimitOrderSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/SimulateWithdrawFilledLimitOrder" => {
                    #[allow(non_camel_case_types)]
                    struct SimulateWithdrawFilledLimitOrderSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QuerySimulateWithdrawFilledLimitOrderRequest,
                    > for SimulateWithdrawFilledLimitOrderSvc<T> {
                        type Response = super::QuerySimulateWithdrawFilledLimitOrderResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QuerySimulateWithdrawFilledLimitOrderRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::simulate_withdraw_filled_limit_order(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SimulateWithdrawFilledLimitOrderSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/SimulateCancelLimitOrder" => {
                    #[allow(non_camel_case_types)]
                    struct SimulateCancelLimitOrderSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QuerySimulateCancelLimitOrderRequest,
                    > for SimulateCancelLimitOrderSvc<T> {
                        type Response = super::QuerySimulateCancelLimitOrderResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QuerySimulateCancelLimitOrderRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::simulate_cancel_limit_order(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SimulateCancelLimitOrderSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/neutron.dex.Query/SimulateMultiHopSwap" => {
                    #[allow(non_camel_case_types)]
                    struct SimulateMultiHopSwapSvc<T: Query>(pub Arc<T>);
                    impl<
                        T: Query,
                    > tonic::server::UnaryService<
                        super::QuerySimulateMultiHopSwapRequest,
                    > for SimulateMultiHopSwapSvc<T> {
                        type Response = super::QuerySimulateMultiHopSwapResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::QuerySimulateMultiHopSwapRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Query>::simulate_multi_hop_swap(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SimulateMultiHopSwapSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for QueryServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "neutron.dex.Query";
    impl<T> tonic::server::NamedService for QueryServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// GenesisState defines the dex module's genesis state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisState {
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
    #[prost(message, repeated, tag = "2")]
    pub tick_liquidity_list: ::prost::alloc::vec::Vec<TickLiquidity>,
    #[prost(message, repeated, tag = "3")]
    pub inactive_limit_order_tranche_list: ::prost::alloc::vec::Vec<LimitOrderTranche>,
    #[prost(message, repeated, tag = "4")]
    pub limit_order_tranche_user_list: ::prost::alloc::vec::Vec<LimitOrderTrancheUser>,
    #[prost(message, repeated, tag = "5")]
    pub pool_metadata_list: ::prost::alloc::vec::Vec<PoolMetadata>,
    /// this line is used by starport scaffolding # genesis/proto/state
    #[prost(uint64, tag = "6")]
    pub pool_count: u64,
}
impl ::prost::Name for GenesisState {
    const NAME: &'static str = "GenesisState";
    const PACKAGE: &'static str = "neutron.dex";
    fn full_name() -> ::prost::alloc::string::String {
        "neutron.dex.GenesisState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/neutron.dex.GenesisState".into()
    }
}
